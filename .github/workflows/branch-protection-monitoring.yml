name: Branch Protection Audit

on:
  workflow_dispatch:
  push:
    branches:
      - main

jobs:
  audit:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    env:
      ORG_NAME: devops-saddam
      SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
      GITHUB_TOKEN: ${{ secrets.RULESET_PAT }}
      DEBUG: "true"
      PYTHONUNBUFFERED: "1"

    steps:
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: pip install requests

      - name: Run Branch Protection Audit (with logging)
        run: |
          python - <<'EOF'
          import os, sys, time, json, requests

          ORG = os.getenv("ORG_NAME")
          TOKEN = os.getenv("GITHUB_TOKEN")
          SLACK = os.getenv("SLACK_WEBHOOK")
          DEBUG = os.getenv("DEBUG", "false").lower() == "true"

          def log(msg, level="INFO"):
              print(f"[{level}] {msg}", flush=True)

          def dbg(msg):
              if DEBUG: log(msg, "DEBUG")

          headers = {
              "Authorization": f"Bearer {TOKEN}",
              "Accept": "application/vnd.github+json"
          }

          def get_json(url, name=""):
              dbg(f"GET {url}")
              r = requests.get(url, headers=headers, timeout=30)
              dbg(f"→ HTTP {r.status_code} for {name or url}")
              if r.status_code == 200:
                  return r.json()
              elif r.status_code == 404:
                  dbg(f"{name or url} not found")
                  return None
              else:
                  log(f"{url} failed: {r.status_code} {r.text[:400]}", "WARN")
                  return None

          def get_repos():
              repos, page = [], 1
              while True:
                  data = get_json(f"https://api.github.com/orgs/{ORG}/repos?per_page=100&page={page}", f"repos page {page}")
                  if not data: break
                  repos.extend(data)
                  dbg(f"Fetched {len(data)} repos (page {page})")
                  if len(data) < 100: break
                  page += 1
              log(f"Total repos found: {len(repos)}")
              return repos

          def get_branch_rules(repo, branch):
              """Unified endpoint returns a list of rule objects."""
              url = f"https://api.github.com/repos/{ORG}/{repo}/rules/branches/{branch}"
              return get_json(url, f"rules for {repo}/{branch}")

          log(f"Starting audit for org: {ORG}")
          repos = get_repos()
          missing, ok = [], []

          for i, repo in enumerate(repos, start=1):
              name = repo["name"]
              branch = repo["default_branch"]
              log(f"[{i}/{len(repos)}] Checking {name}/{branch}")

              rules = get_branch_rules(name, branch)
              if rules is None:
                  missing.append({"repo": name, "missing": ["No branch protection or ruleset found"]})
                  continue

              if isinstance(rules, dict):
                  # rare case, normalize to list
                  rules = rules.get("rules", [])

              dbg(f"Rule count for {name}: {len(rules)}")
              for r in rules:
                  dbg(f"  Type: {r.get('type')} Params: {json.dumps(r.get('parameters', {}), indent=2)}")

              types = {r.get("type"): r for r in rules}
              repo_missing = []

              if "pull_request" not in types:
                  repo_missing.append("Require pull request before merging not enabled")

              if "required_approving_review_count" not in types:
                  repo_missing.append("Required approving reviews rule missing")
              else:
                  params = types["required_approving_review_count"].get("parameters", {})
                  count = params.get("required_approving_review_count") or params.get("count", 0)
                  if int(count) < 2:
                      repo_missing.append(f"Required approving reviews = {count} (expected 2)")

              if "non_fast_forward" not in types:
                  repo_missing.append("Non-fast-forward merge rule missing")

              if repo_missing:
                  log(f"{name}: ❌ Issues → {', '.join(repo_missing)}")
                  missing.append({"repo": name, "missing": repo_missing})
              else:
                  log(f"{name}: ✅ Compliant")
                  ok.append(name)

          summary = f"{len(ok)} repos compliant, {len(missing)} with issues"
          log(f"Audit complete. {summary}")

          blocks = [{
              "type": "section",
              "text": {"type": "mrkdwn", "text": f"*Branch Protection Audit Summary*\n{summary}"}
          }]

          if missing:
              blocks.append({"type": "header", "text": {"type": "plain_text", "text": "❌ Missing / Misconfigured Protections"}})
              for m in missing:
                  detail = "\n".join([f"• {d}" for d in m["missing"]])
                  blocks.append({
                      "type": "section",
                      "text": {"type": "mrkdwn", "text": f"*Repository:* `{m['repo']}`\n{detail}"}
                  })
                  blocks.append({"type": "divider"})
          else:
              blocks.append({"type": "section", "text": {"type": "mrkdwn", "text": "✅ All repositories compliant."}})

          try:
              r = requests.post(SLACK, json={"blocks": blocks}, timeout=30)
              log(f"Slack post → HTTP {r.status_code}")
          except Exception as e:
              log(f"Slack post failed: {e}", "WARN")
          EOF
