name: Branch Protection Detailed Audit (Rules API + Slack)

on:
  workflow_dispatch:
  push:
    branches:
      - ops-7840-github-branch-protection-rule-monitoring
      - main

jobs:
  audit:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    env:
      ORG_NAME: ${{ github.repository_owner }}
      GITHUB_TOKEN: ${{ secrets.RULESET_PAT }}
      SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
      DEBUG: "true"
      PYTHONUNBUFFERED: "1"

    steps:
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install dependencies
        run: pip install requests

      - name: Run Unified Branch Protection Audit
        run: |
          python - <<'EOF'
          import os, requests

          ORG = os.getenv("ORG_NAME")
          TOKEN = os.getenv("GITHUB_TOKEN")
          SLACK = os.getenv("SLACK_WEBHOOK")
          DEBUG = os.getenv("DEBUG","false").lower()=="true"

          def log(m,l="INFO"): print(f"[{l}] {m}", flush=True)
          def dbg(m): 
              if DEBUG: log(m,"DEBUG")

          H = {"Authorization": f"Bearer {TOKEN}", "Accept": "application/vnd.github+json"}

          def get_json(url):
              r = requests.get(url, headers=H, timeout=30)
              dbg(f"GET {url} -> {r.status_code}")
              if r.status_code==200: return r.json()
              if r.status_code==404: return None
              log(f"Failed GET {url} -> {r.status_code}: {r.text[:150]}", "WARN")
              return None

          def graphql(query: str, variables: dict):
              url = "https://api.github.com/graphql"
              headers = {**H, "Content-Type": "application/json"}
              payload = {"query": query, "variables": variables}
              r = requests.post(url, json=payload, headers=headers, timeout=30)
              dbg(f"POST /graphql -> {r.status_code}")
              if r.status_code != 200:
                  log(f"GraphQL error {r.status_code}: {r.text[:200]}", "WARN")
                  return None
              data = r.json()
              if "errors" in data:
                  log(f"GraphQL errors: {data['errors']}", "WARN")
                  return None
              return data.get("data")

          def list_repos():
              repos, page = [], 1
              while True:
                  data = get_json(f"https://api.github.com/orgs/{ORG}/repos?per_page=100&page={page}&type=all")
                  if not data: break
                  repos += data
                  if len(data) < 100: break
                  page += 1
              return repos

          def get_rules(repo, branch):
              return get_json(f"https://api.github.com/repos/{ORG}/{repo}/rules/branches/{branch}") or []

          def get_classic_branch_patterns(repo):
              # Use GraphQL to fetch classic branch protection rule patterns without enumerating branches
              q = """
              query($owner:String!, $name:String!) {
                repository(owner:$owner, name:$name) {
                  branchProtectionRules(first: 50) {
                    nodes {
                      pattern
                      requiresApprovingReviews
                      requiredApprovingReviewCount
                      dismissesStaleReviews
                      requiresStatusChecks
                      requiresCodeOwnerReviews
                      allowsDeletions
                      allowsForcePushes
                    }
                  }
                }
              }
              """
              data = graphql(q, {"owner": ORG, "name": repo})
              patterns = []
              if not data or not data.get("repository"):
                  return patterns
              nodes = (data["repository"].get("branchProtectionRules") or {}).get("nodes") or []
              for n in nodes:
                  patterns.append(n)
              return patterns

          # ---- Start
          repos = list_repos()
          log(f"Total repositories found: {len(repos)}")
          for r in repos: log(f"→ {r['name']}")

          missing, ok = [], []

          for idx, repo in enumerate(repos, start=1):
              name = repo["name"]
              default_branch = repo.get("default_branch", "main")
              log(f"\n[{idx}/{len(repos)}] Checking repository: {name}")
              log(f"Default branch for {name} is '{default_branch}'")

              issues = []
              
              # Step 2: Check rules on default branch directly using Rules API (works with RULESET_PAT)
              rules = get_rules(name, default_branch)
              
              if not rules:
                  # No protection found on default branch — see if classic protection exists targeting another pattern
                  classic_rules = get_classic_branch_patterns(name)
                  if classic_rules:
                      patterns = [r.get("pattern") for r in classic_rules if r.get("pattern")]
                      if patterns and default_branch not in patterns:
                          log(f"{name}: ⚠️ Misconfigured branch protection found: Default branch is '{default_branch}' but classic branch protection is configured for {', '.join(patterns)}")
                          missing.append({
                              "repo": name,
                              "issues": [f"Misconfigured branch protection found: Default branch is '{default_branch}' but classic branch protection is configured for {', '.join(patterns)}"],
                              "source": "mismatch"
                          })
                          continue
                      # Classic rule exists for default branch but not shown by Rules API (edge). Validate with GraphQL fields.
                      issues = []
                      for n in classic_rules:
                          if n.get("pattern") == default_branch:
                              if not n.get("requiresApprovingReviews"):
                                  issues.append("Require pull request before merging not enabled")
                              else:
                                  cnt = n.get("requiredApprovingReviewCount") or 0
                                  if int(cnt) != 2:
                                      issues.append(f"Required approvals = {cnt}, expected 2")
                              if not n.get("dismissesStaleReviews"):
                                  issues.append("Dismiss stale pull request approvals when new commits are pushed not enabled")
                              if not n.get("requiresStatusChecks"):
                                  issues.append("Require status checks to pass before merging not enabled")
                              # Optional checks
                              if n.get("allowsForcePushes"):
                                  issues.append("Block force pushes rule not enabled")
                              if n.get("allowsDeletions"):
                                  issues.append("Restrict deletions rule not enabled")
                              break
                      if issues:
                          log(f"{name}: ❌ Issues (classic branch protection) → {', '.join(issues)}")
                          missing.append({"repo": name, "issues": issues, "source": "classic"})
                      else:
                          log(f"{name}: ❌ No branch protection rule or ruleset configured on default branch '{default_branch}'")
                          missing.append({
                              "repo": name,
                              "issues": [f"No branch protection rule or ruleset configured on default branch '{default_branch}'"],
                              "source": "no protection"
                          })
                  else:
                      log(f"{name}: ❌ No branch protection rule or ruleset configured on default branch '{default_branch}'")
                      missing.append({
                          "repo": name,
                          "issues": [f"No branch protection rule or ruleset configured on default branch '{default_branch}'"],
                          "source": "no protection"
                      })
                  continue

              # Rules found on default branch - determine if classic or ruleset
              rule_source = None
              ruleset_name = None
              
              for rule in rules:
                  if rule.get("source") == "BranchProtectionRule":
                      rule_source = "classic"
                      break
                  elif rule.get("source") == "RepositoryRuleSet":
                      rule_source = "ruleset"
                      ruleset_name = rule.get("ruleset_name") or rule.get("name", "unknown")
                      break

              if not rule_source:
                  rule_source = "unknown"

              if rule_source == "classic":
                  log(f"{name}: Found classic branch protection rule on '{default_branch}'")
                  # Verify classic branch protection settings via Rules API
                  rule_types = {r.get("type"): r for r in rules}
                  
                  if "pull_request" not in rule_types:
                      issues.append("Require pull request before merging not enabled")

                  if "required_approving_review_count" not in rule_types:
                      issues.append("Required approving reviews rule missing")
                  else:
                      params = rule_types["required_approving_review_count"].get("parameters") or {}
                      count = params.get("required_approving_review_count") or params.get("count")
                      if not count:
                          issues.append("Approvals rule present but count missing")
                      elif int(count) != 2:
                          issues.append(f"Required approvals = {count}, expected 2")

                  if "dismiss_stale_reviews" not in rule_types:
                      issues.append("Dismiss stale pull request approvals when new commits are pushed not enabled")

                  # Note: Status checks and other classic protection features may not be available via Rules API
                  # We focus on the core requirements that are available

                  if issues:
                      log(f"{name}: ❌ Issues (classic branch protection) → {', '.join(issues)}")
                      missing.append({"repo": name, "issues": issues, "source": "classic"})
                  else:
                      log(f"{name}: ✅ All required rules in place (classic branch protection)")
                      ok.append(name)

              elif rule_source == "ruleset":
                  log(f"{name}: Found ruleset '{ruleset_name}' on '{default_branch}'")
                  # Ruleset matches default branch, now check the rules
                  rule_types = {r.get("type"): r for r in rules}
                  
                  if "pull_request" not in rule_types:
                      issues.append("Require pull request before merging not enabled")

                  if "required_approving_review_count" not in rule_types:
                      issues.append("Required approving reviews rule missing")
                  else:
                      params = rule_types["required_approving_review_count"].get("parameters") or {}
                      count = params.get("required_approving_review_count") or params.get("count")
                      if not count:
                          issues.append("Approvals rule present but count missing")
                      elif int(count) != 2:
                          issues.append(f"Required approvals = {count}, expected 2")

                  if "dismiss_stale_reviews" not in rule_types:
                      issues.append("Dismiss stale pull request approvals when new commits are pushed not enabled")

                  if "restrict_deletions" not in rule_types:
                      issues.append("Restrict deletions rule not enabled")

                  if "non_fast_forward" not in rule_types:
                      issues.append("Block force pushes rule not enabled")

                  if issues:
                      log(f"{name}: ❌ Issues (ruleset '{ruleset_name}') → {', '.join(issues)}")
                      missing.append({"repo": name, "issues": issues, "source": f"ruleset '{ruleset_name}'"})
                  else:
                      log(f"{name}: ✅ All required rules in place (ruleset '{ruleset_name}')")
                      ok.append(name)
              else:
                  log(f"{name}: ❌ Unknown or invalid branch protection configuration")
                  missing.append({
                      "repo": name,
                      "issues": ["Unknown or invalid branch protection configuration"],
                      "source": "unknown"
                  })

          # ---- Slack reporting with chunking to avoid payload limits
          if SLACK:
              def build_summary_block():
                  return {
                      "type": "section",
                      "text": {
                          "type": "mrkdwn",
                          "text": (
                              f"*Branch Protection Audit Summary*\n"
                              f"Total repositories: {len(repos)}\n"
                              f"✅ Compliant: {len(ok)}\n"
                              f"❌ With Issues: {len(missing)}"
                          )
                      }
                  }

              def build_repo_block(entry):
                  repo_name = entry["repo"]
                  # Show only the repository name as the heading to avoid duplicated phrasing
                  heading = f"*{repo_name}*"
                  # Render each issue as a bullet point underneath
                  issues_text = "\n".join([f"• {i}" for i in entry.get("issues", [])]) or "• No specific issues provided"
                  # Truncate overly long section text to stay within Slack limits
                  if len(issues_text) > 2500:
                      issues_text = issues_text[:2470] + "… (truncated)"
                  return {
                      "type": "section",
                      "text": {"type": "mrkdwn", "text": f"{heading}\n{issues_text}"}
                  }

              # Always send a short summary first
              summary_text = (
                  f"Branch Protection Audit Summary\n"
                  f"Total repositories: {len(repos)}\n"
                  f"✅ Compliant: {len(ok)}\n"
                  f"❌ With Issues: {len(missing)}"
              )
              first_payload = {"text": summary_text, "blocks": [build_summary_block()]}
              try:
                  r = requests.post(SLACK, json=first_payload, timeout=30)
                  log(f"Slack summary POST -> {r.status_code}")
                  if r.status_code != 200:
                      log(f"Slack error response: {r.text}", "WARN")
              except Exception as e:
                  log(f"Slack summary POST failed: {e}", "WARN")

              if missing:
                  # Build all repo blocks (each repo adds 2 blocks: section + divider)
                  repo_blocks = []
                  header_block = {"type": "header", "text": {"type": "plain_text", "text": "Repositories with Issues"}}
                  divider = {"type": "divider"}
                  for m in missing:
                      repo_blocks.append(build_repo_block(m))
                      repo_blocks.append(divider)

                  # Chunk to respect Slack's 50-block limit per message; keep margin -> max 40 blocks
                  MAX_BLOCKS_PER_MESSAGE = 40
                  chunk = []
                  for b in repo_blocks:
                      chunk.append(b)
                      if len(chunk) >= MAX_BLOCKS_PER_MESSAGE:
                          payload = {"text": "Branch protection issues (part)", "blocks": [header_block] + chunk}
                          try:
                              r = requests.post(SLACK, json=payload, timeout=30)
                              log(f"Slack details POST -> {r.status_code}")
                              if r.status_code != 200:
                                  log(f"Slack error response: {r.text}", "WARN")
                          except Exception as e:
                              log(f"Slack details POST failed: {e}", "WARN")
                          chunk = []

                  if chunk:
                      payload = {"text": "Branch protection issues (final)", "blocks": [header_block] + chunk}
                      try:
                          r = requests.post(SLACK, json=payload, timeout=30)
                          log(f"Slack details POST -> {r.status_code}")
                          if r.status_code != 200:
                              log(f"Slack error response: {r.text}", "WARN")
                      except Exception as e:
                          log(f"Slack details POST failed: {e}", "WARN")
          else:
              log("No SLACK_WEBHOOK set, skipping Slack notification.", "WARN")
          EOF
