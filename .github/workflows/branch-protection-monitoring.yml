name: Branch Protection Detailed Audit (Classic + Ruleset + Slack)

on:
  workflow_dispatch:
  push:                   # ✅ Trigger on any push to test behavior
    branches:
      - main               # or your preferred branch

jobs:
  audit:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    env:
      ORG_NAME: devops-saddam
      GITHUB_TOKEN: ${{ secrets.RULESET_PAT }}
      SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
      DEBUG: "true"
      PYTHONUNBUFFERED: "1"

    steps:
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install dependencies
        run: pip install requests

      - name: Run Branch Protection Audit
        run: |
          python - <<'EOF'
          import os, requests

          ORG = os.getenv("ORG_NAME")
          TOKEN = os.getenv("GITHUB_TOKEN")
          SLACK = os.getenv("SLACK_WEBHOOK")
          DEBUG = os.getenv("DEBUG","false").lower()=="true"

          def log(m,l="INFO"): print(f"[{l}] {m}", flush=True)
          def dbg(m): 
              if DEBUG: log(m,"DEBUG")

          H = {"Authorization": f"Bearer {TOKEN}", "Accept": "application/vnd.github+json"}

          def get_json(url):
              r = requests.get(url, headers=H, timeout=30)
              dbg(f"GET {url} -> {r.status_code}")
              if r.status_code==200: return r.json()
              if r.status_code==404: return None
              log(f"Failed GET {url} -> {r.status_code}: {r.text[:150]}", "WARN")
              return None

          def list_repos():
              repos, page = [], 1
              while True:
                  data = get_json(f"https://api.github.com/orgs/{ORG}/repos?per_page=100&page={page}")
                  if not data: break
                  repos += data
                  if len(data) < 100: break
                  page += 1
              return repos

          def list_branches(repo):
              branches, page = [], 1
              while True:
                  data = get_json(f"https://api.github.com/repos/{ORG}/{repo}/branches?per_page=100&page={page}")
                  if not data: break
                  branches += [b["name"] for b in data]
                  if len(data) < 100: break
                  page += 1
              return branches

          def get_classic_protection(repo, branch):
              r = requests.get(f"https://api.github.com/repos/{ORG}/{repo}/branches/{branch}/protection", headers=H, timeout=30)
              dbg(f"Classic check: {branch} -> {r.status_code}")
              return r.json() if r.status_code==200 else None

          def get_rules(repo, branch):
              return get_json(f"https://api.github.com/repos/{ORG}/{repo}/rules/branches/{branch}") or []

          repos = list_repos()
          log(f"Total repositories found: {len(repos)}")
          for r in repos: log(f"→ {r['name']}")

          missing, ok = [], []

          for idx, repo in enumerate(repos, start=1):
              name = repo["name"]
              default_branch = repo["default_branch"]
              log(f"\n[{idx}/{len(repos)}] Checking repository: {name}")
              log(f"Default branch for {name} is '{default_branch}'")

              branches = list_branches(name)
              classic_found = []
              classic_data = {}

              # Look for any classic branch protection rules
              for b in branches:
                  prot = get_classic_protection(name, b)
                  if prot:
                      classic_found.append(b)
                      classic_data[b] = prot

              if classic_found:
                  dbg(f"Classic branch protection found: {classic_found}")
                  if default_branch not in classic_found:
                      log(f"{name}: ⚠️ Mismatch — classic protection exists for {classic_found} but default branch is '{default_branch}'")
                      missing.append({
                          "repo": name,
                          "issues": [f"Misconfigured branch protection: default branch is '{default_branch}' but classic branch protection is configured for {', '.join(classic_found)}."],
                          "source": "mismatch"
                      })
                      continue
                  else:
                      prot = classic_data[default_branch]
                      issues = []

                      reqs = prot.get("required_pull_request_reviews")
                      if not reqs:
                          issues.append("Require pull request before merging not enabled")
                      elif reqs.get("required_approving_review_count",0) < 2:
                          issues.append(f"Approvals required = {reqs.get('required_approving_review_count',0)}, expected 2")

                      if not prot.get("dismiss_stale_reviews", False):
                          issues.append("Dismiss stale pull request approvals not enabled")

                      if not prot.get("restrictions", None):
                          pass  # restrictions not mandatory
                      if not prot.get("allow_deletions") == False:
                          issues.append("Restrict deletions rule not enabled")

                      if not prot.get("allow_force_pushes") == False:
                          issues.append("Block force pushes rule not enabled")

                      if issues:
                          missing.append({"repo": name, "issues": issues, "source": "classic"})
                          log(f"{name}: ❌ Issues in classic rule → {', '.join(issues)}")
                          continue
                      else:
                          ok.append(name)
                          log(f"{name}: ✅ Classic rule correctly configured")
                          continue

              # Fallback to ruleset-based protection
              rules = get_rules(name, default_branch)
              if not rules:
                  log(f"{name}: ❌ No branch protection or ruleset configured")
                  missing.append({
                      "repo": name,
                      "issues": ["No branch protection rule or ruleset configured"],
                      "source": "no protection"
                  })
                  continue

              rule_source = "ruleset"
              if rules and rules[0].get("name"):
                  rule_source = f"ruleset '{rules[0]['name']}'"

              rule_types = {r.get("type"): r for r in rules}
              issues=[]

              if "pull_request" not in rule_types:
                  issues.append("Require pull request before merging not enabled")
              if "required_approving_review_count" not in rule_types:
                  issues.append("Required approving reviews rule missing")
              else:
                  params = rule_types["required_approving_review_count"].get("parameters") or {}
                  count = params.get("required_approving_review_count") or params.get("count")
                  if not count or int(count) < 2:
                      issues.append(f"Approvals required = {count or 0}, expected 2")
              if "dismiss_stale_reviews" not in rule_types:
                  issues.append("Dismiss stale pull request approvals not enabled")
              if "restrict_deletions" not in rule_types:
                  issues.append("Restrict deletions rule not enabled")
              if "non_fast_forward" not in rule_types:
                  issues.append("Block force pushes rule not enabled")

              if issues:
                  missing.append({"repo": name, "issues": issues, "source": rule_source})
                  log(f"{name}: ❌ Issues ({rule_source}) → {', '.join(issues)}")
              else:
                  ok.append(name)
                  log(f"{name}: ✅ All required rules in place ({rule_source})")

          # ---- Slack summary
          if SLACK:
              summary = (
                  f"*Branch Protection Audit Summary*\n"
                  f"Total repositories: {len(repos)}\n"
                  f"✅ Compliant: {len(ok)}\n"
                  f"❌ With Issues: {len(missing)}"
              )
              blocks=[{"type":"section","text":{"type":"mrkdwn","text":summary}}]
              if missing:
                  blocks.append({"type":"divider"})
                  blocks.append({"type":"header","text":{"type":"plain_text","text":"Repositories with Issues"}})
                  for m in missing:
                      repo=m["repo"]; src=m.get("source","unknown")
                      if src=="no protection":
                          heading=f"*{repo}*\nNo branch protection rule or ruleset configured"
                      elif src=="mismatch":
                          heading=f"*{repo}*\nMisconfigured branch protection found"
                      elif "ruleset" in src:
                          heading=f"*{repo}*\nFound {src} applied"
                      elif src=="classic":
                          heading=f"*{repo}*\nFound classic branch protection rule"
                      else:
                          heading=f"*{repo}*\n{src}"
                      issues="\n".join([f"• {i}" for i in m["issues"]])
                      blocks.append({"type":"section","text":{"type":"mrkdwn","text":f"{heading}\n{issues}"}})
                      blocks.append({"type":"divider"})
              else:
                  blocks.append({"type":"section","text":{"type":"mrkdwn","text":"✅ All repositories are fully compliant."}})
              try:
                  r=requests.post(SLACK,json={"blocks":blocks},timeout=30)
                  log(f"Slack POST -> {r.status_code}")
              except Exception as e:
                  log(f"Slack POST failed: {e}","WARN")
          else:
              log("No SLACK_WEBHOOK set, skipping Slack notification.","WARN")
          EOF
