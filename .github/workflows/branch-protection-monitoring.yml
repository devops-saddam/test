name: Branch Protection Detailed Audit (Rules API + Slack)

on:
  workflow_dispatch:
  push:                   # ✅ Trigger on any push to test behavior
    branches:
      - main               # or your preferred branch

jobs:
  audit:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    env:
      ORG_NAME: devops-saddam
      GITHUB_TOKEN: ${{ secrets.RULESET_PAT }}
      SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
      DEBUG: "true"
      PYTHONUNBUFFERED: "1"

    steps:
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install dependencies
        run: pip install requests

      - name: Run Unified Branch Protection Audit
        run: |
          python - <<'EOF'
          import os, requests, json

          ORG = os.getenv("ORG_NAME")
          TOKEN = os.getenv("GITHUB_TOKEN")
          SLACK = os.getenv("SLACK_WEBHOOK")
          DEBUG = os.getenv("DEBUG", "false").lower() == "true"

          def log(msg, lvl="INFO"): print(f"[{lvl}] {msg}", flush=True)
          def dbg(msg): 
              if DEBUG: log(msg, "DEBUG")

          headers = {
              "Authorization": f"Bearer {TOKEN}",
              "Accept": "application/vnd.github+json"
          }

          def get_json(url):
              r = requests.get(url, headers=headers, timeout=30)
              dbg(f"GET {url} → {r.status_code}")
              if r.status_code == 200:
                  return r.json()
              elif r.status_code == 404:
                  return None
              else:
                  log(f"Failed GET {url} → {r.status_code}: {r.text[:200]}", "WARN")
                  return None

          def get_repos():
              repos, page = [], 1
              while True:
                  url = f"https://api.github.com/orgs/{ORG}/repos?per_page=100&page={page}"
                  data = get_json(url)
                  if not data: break
                  repos.extend(data)
                  if len(data) < 100: break
                  page += 1
              return repos

          def get_branch_rules(repo, branch):
              url = f"https://api.github.com/repos/{ORG}/{repo}/rules/branches/{branch}"
              return get_json(url)

          def get_rulesets(repo):
              url = f"https://api.github.com/repos/{ORG}/{repo}/rulesets"
              return get_json(url) or []

          # --- Start ---
          repos = get_repos()
          log(f"Total repositories found: {len(repos)}")
          for r in repos: log(f"→ {r['name']}")

          missing, ok = [], []

          for idx, repo in enumerate(repos, start=1):
              name = repo["name"]
              default_branch = repo["default_branch"]
              log(f"\n[{idx}/{len(repos)}] Checking repository: {name}")
              log(f"Default branch for {name} is '{default_branch}'")

              # 1️⃣  Get branch-specific rules
              branch_rules = get_branch_rules(name, default_branch)
              # 2️⃣  Also fetch all rulesets for mismatch detection
              rulesets = get_rulesets(name)
              dbg(f"Total rulesets found for {name}: {len(rulesets)}")

              # --- Case: No rules found at all
              if not branch_rules and not rulesets:
                  log(f"{name}: ❌ No branch protection rule or ruleset configured")
                  missing.append({
                      "repo": name,
                      "issues": ["No branch protection rule or ruleset configured"],
                      "source": "no protection"
                  })
                  continue

              # --- Detect branch protection mismatch
              branch_patterns = []
              for rs in rulesets:
                  cond = rs.get("conditions", {})
                  ref_name = cond.get("ref_name", {})
                  includes = ref_name.get("include") or []
                  for pattern in includes:
                      branch_patterns.append(pattern)

              dbg(f"Branch patterns detected: {branch_patterns}")
              if branch_patterns and all(default_branch not in pat for pat in branch_patterns):
                  log(f"{name}: ⚠️ Mismatch — protection applies to {branch_patterns} but default branch is '{default_branch}'")
                  missing.append({
                      "repo": name,
                      "issues": [f"Misconfigured branch protection: Default branch is '{default_branch}' but protection applies to {', '.join(branch_patterns)}"],
                      "source": "mismatch"
                  })
                  continue

              # --- Evaluate actual rules for default branch
              rules = branch_rules or []
              if not rules:
                  log(f"{name}: ❌ No branch protection rules found for default branch '{default_branch}'")
                  missing.append({
                      "repo": name,
                      "issues": [f"No branch protection rules found for default branch '{default_branch}'"],
                      "source": "no protection"
                  })
                  continue

              rule_source = "classic"
              if any(r.get("source") == "RepositoryRuleset" for r in rules):
                  rule_source = "ruleset"
                  name_field = rules[0].get("name")
                  if name_field:
                      rule_source = f"ruleset '{name_field}'"

              rule_types = {r.get("type"): r for r in rules}
              issues = []

              if "pull_request" not in rule_types:
                  issues.append("Require pull request before merging not enabled")
              if "required_approving_review_count" not in rule_types:
                  issues.append("Required approving reviews rule missing")
              else:
                  params = rule_types["required_approving_review_count"].get("parameters") or {}
                  count = params.get("required_approving_review_count") or params.get("count")
                  if not count:
                      issues.append("Approvals rule present but count missing")
                  elif int(count) < 2:
                      issues.append(f"Approvals required = {count}, expected 2")
              if "dismiss_stale_reviews" not in rule_types:
                  issues.append("Dismiss stale pull request approvals not enabled")
              if "restrict_deletions" not in rule_types:
                  issues.append("Restrict deletions rule not enabled")
              if "non_fast_forward" not in rule_types:
                  issues.append("Block force pushes rule not enabled")

              if issues:
                  log(f"{name}: ❌ Issues ({rule_source}) → {', '.join(issues)}")
                  missing.append({"repo": name, "issues": issues, "source": rule_source})
              else:
                  log(f"{name}: ✅ All required rules in place ({rule_source})")
                  ok.append(name)

          # --- Slack Notification ---
          if SLACK:
              summary = (
                  f"*Branch Protection Audit Summary*\n"
                  f"Total repositories: {len(repos)}\n"
                  f"✅ Compliant: {len(ok)}\n"
                  f"❌ With Issues: {len(missing)}"
              )
              blocks = [{"type": "section", "text": {"type": "mrkdwn", "text": summary}}]

              if missing:
                  blocks.append({"type": "divider"})
                  blocks.append({
                      "type": "header",
                      "text": {"type": "plain_text", "text": "Repositories with Issues"}
                  })
                  for m in missing:
                      repo_name = m["repo"]
                      source = m.get("source", "unknown protection")
                      if source == "no protection":
                          heading = f"*{repo_name}*\nNo branch protection rule or ruleset configured"
                      elif source == "mismatch":
                          heading = f"*{repo_name}*\nMisconfigured branch protection found"
                      elif "ruleset" in source:
                          heading = f"*{repo_name}*\nFound {source} applied"
                      elif source == "classic":
                          heading = f"*{repo_name}*\nFound classic branch protection rule"
                      else:
                          heading = f"*{repo_name}*\n{source}"

                      issues = "\n".join([f"• {i}" for i in m["issues"]])
                      blocks.append({
                          "type": "section",
                          "text": {"type": "mrkdwn", "text": f"{heading}\n{issues}"}
                      })
                      blocks.append({"type": "divider"})
              else:
                  blocks.append({
                      "type": "section",
                      "text": {"type": "mrkdwn", "text": "✅ All repositories are fully compliant."}
                  })

              try:
                  resp = requests.post(SLACK, json={"blocks": blocks}, timeout=30)
                  log(f"Slack POST → {resp.status_code}")
              except Exception as e:
                  log(f"Slack POST failed: {e}", "WARN")
          else:
              log("No SLACK_WEBHOOK set, skipping Slack notification.", "WARN")
          EOF
